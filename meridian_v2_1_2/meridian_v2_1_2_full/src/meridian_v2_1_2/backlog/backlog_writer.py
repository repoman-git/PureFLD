"""
Backlog Writer for Meridian v2.1.2

Generates BACKLOG.md from registry.
"""

from pathlib import Path
from typing import List

from .backlog_registry import BacklogRegistry
from .backlog_parser import Task, TaskStatus


class BacklogWriter:
    """
    Writes backlog to markdown format.
    
    Generates clean, readable BACKLOG.md
    """
    
    def __init__(self, registry: BacklogRegistry, config):
        """
        Initialize backlog writer.
        
        Args:
            registry: BacklogRegistry instance
            config: BacklogConfig instance
        """
        self.registry = registry
        self.config = config
    
    def write(self, output_path: Path = None) -> Path:
        """
        Write backlog to file.
        
        Args:
            output_path: Optional output path
        
        Returns:
            Path to written file
        """
        if output_path is None:
            output_path = Path(self.config.backlog_filename)
        
        content = self._generate_markdown()
        
        output_path.write_text(content)
        
        return output_path
    
    def _generate_markdown(self) -> str:
        """Generate markdown content"""
        lines = []
        
        # Header
        lines.append("# MERIDIAN v2.1.2 â€” PROJECT BACKLOG")
        lines.append("")
        lines.append("*Auto-generated by Backlog Manager*")
        lines.append("")
        
        # Statistics
        stats = self.registry.get_statistics()
        lines.append("## ðŸ“Š Statistics")
        lines.append("")
        lines.append(f"- **Total Tasks**: {stats['total_tasks']}")
        lines.append(f"- **TODO**: {stats['todo']}")
        lines.append(f"- **In Progress**: {stats['in_progress']}")
        lines.append(f"- **Done**: {stats['done']}")
        lines.append(f"- **High Priority**: {stats['high_priority']}")
        lines.append(f"- **Phases**: {stats['phases']}")
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # Tasks by phase
        phases = self.registry.get_all_phases()
        
        for phase in phases:
            tasks = self.registry.get_tasks_by_phase(phase)
            
            if not tasks:
                continue
            
            lines.append(f"## Phase {phase}")
            lines.append("")
            
            # Sort tasks if configured
            if self.config.sort_by_priority:
                tasks = sorted(tasks, key=lambda t: (
                    {'HIGH': 0, 'MEDIUM': 1, 'LOW': 2}[t.priority.value],
                    t.title
                ))
            
            for task in tasks:
                lines.append(self._format_task(task))
            
            lines.append("")
        
        # Orphan tasks
        if self.config.include_orphans:
            orphans = self.registry.get_orphan_tasks()
            
            if orphans:
                lines.append("## ðŸ“¦ Unassigned Tasks")
                lines.append("")
                
                for task in orphans:
                    lines.append(self._format_task(task))
                
                lines.append("")
        
        lines.append("---")
        lines.append("")
        lines.append("*Generated by Meridian Backlog Manager v1*")
        lines.append("")
        
        return '\n'.join(lines)
    
    def _format_task(self, task: Task) -> str:
        """Format task as markdown checkbox"""
        # Status checkbox
        if task.status == TaskStatus.DONE:
            checkbox = "[x]"
        elif task.status == TaskStatus.IN_PROGRESS:
            checkbox = "[~]"
        else:
            checkbox = "[ ]"
        
        # Priority indicator
        if task.priority.value == 'HIGH':
            priority_marker = "ðŸ”´"
        elif task.priority.value == 'MEDIUM':
            priority_marker = "ðŸŸ¡"
        else:
            priority_marker = ""
        
        # Format line
        parts = [f"- {checkbox}"]
        
        if priority_marker:
            parts.append(priority_marker)
        
        parts.append(task.title)
        
        if task.module:
            parts.append(f"*({task.module})*")
        
        return " ".join(parts)


